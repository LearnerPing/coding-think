# 《代码整洁之道》Note
## 第一章 整洁的代码
  * 低水平的编码者就像一群猴子一样，写出一堆可以运行的杂乱无章的代码就以为自己掌握了编程的真谛，只看最终的结果而无视代码的混乱，坐等混乱发酵直至毁掉整个系统。 写代码是终究是一件需要考虑长远的事情，目光短浅只顾当下无疑会让自己成为一只Code Monkey
  * 混乱的代码无疑会导致工作因为各种奇怪的原因延期，而当这种混乱堆积到一种程度，就不得不选择重新构建一个新的系统，这对一个项目团队而已可不是什么好事。
  * 勒布朗法则：稍后等于永不。  面对尚可运行的混乱代码，留一句以后有时间了再去清理毫无意义，这个以后总是会变成下次一定。 在开发的初期就应该设立良好的可拓展的架构，整洁的代码会对未来的工作有至关重要的作用。
## 第二章 有意义的命名
  * 变量的命名应该做到名副其实，让别人看到你的代码的时候不会产生这个变量是什么意思的疑问
  * 提防使用不同之处较小的名称
  * 做有意义的区分
  * 使用读的出来的名称
  * 使用可以搜索的名称，避免使用数字这种会有大量重复的内容进行命名
  * 避免使用成员前缀，使变量名和函数名尽可能的短
  * 类名和对象名应该是名词和短语，不应该出现动词
  * 方法名应该由动词和动词短语命名
## 第三章 函数 
* 短小，一个函数只做一件事。要达到这个目的，需要函数内部的代码都处于一个抽象层，在尽可能缩小函数体积的前提下，进行一个描述性的命名能更精准的传达函数实现的功能
* 函数的参数数量不应该超过2个，当函数过长的时候就应该考虑参数封装成类
* 普遍而言，应该避免使用输出函数，如果函数必须修改某种状态，那就修改所属对象的状态
* 使用异常代替返回错误代码，更直观得反映错误
## 第四章 注释
* 简洁扼要的说明
## 第五章 格式
* 一个统一的格式化工具对于阅读代码会很有很大的帮助
* 若一个函数调用了另一个，就应该把他们放到一起，而且调用者应该尽可能的在被调用者上面
## 第六章 对象和数据结构
* 得墨忒耳定律： 模块不应该了解它所操作对象的内部情况
## 第七章 使用异常而非返回码
* 使用不可控异常，可控异常 checked exception 的代价是违反开闭原则
* 根据调用者的不同需求来定义异常类，来捕获某个特定类型的异常
* 不要返回NULL值，不要返回NULL值，调用者如果没有校验/处理NULL值 很容易就会引起程序的崩溃
## 第八章
* 略
## 第九章 单元测试
*  定律一 在编写不能通过的单元测试前，不可编写生产代码。<br>
定律二 只可编写刚好无法通过的单元测试，不能编译也算不通过。<br>
定律三 只可编写刚好足以通过当前失败测试的生产代码。<br>
* 好的测试应该遵循F.I.R.S.T 原则，即 快速（Fast）、独立（Independent）、可重复(Repeatable),自足验证（Self-Validating）、及时（Timely）
## 第十章 类
* 类的创建应该遵循 开闭原则：对拓展开放，对修改封闭，通过继承等手段去拓展类<br>
## 第十一章 系统
* 将系统的构造与使用分开。方法之一是将全部构造过程搬迁到Mian函数当中。
* 依赖注入是实现构造与使用分离的强大机制，控制反转（IOC）是依赖管理的一种应用手段，控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循了单一权责原则。在依赖管理情境中，对象不应负责实体化对自身的依赖，而应当将这份权责移交给其它“有权力”的机制，从而实现控制的反转。
* 一开始就做对系统”纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。
## 第十二章 迭进
* 简单设计原则：<br>
   - 运行所有测试；
   - 不可重复；
   - 表达了程序员的意图；
   - 尽可能减少类和方法的数量。
## 第十三章 并发编程
* 并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。
* 同步方法之间的依赖会导致并发代码中的缺陷，建议：避免使用一个共享对象的多个方法。不得不使用的时候有3种方案：<br>
  - 基于客户端的锁定
  - 基于服务端的锁定
  - 适配服务端
## 第十七章 启发
* 注释：<br>
   - 避免不恰当的信息
   - 避免废弃的注释
   - 避免冗余注释
   - 不要注释代码，直接删除，通过版本控制系统去追朔<br>
* 函数：<br>
   - 避免过多的参数
   - 尽量不要使用输出参数，通过修改对象状态来实现参数输出的效果
   - 标识参数(boolean)应该被抛弃
   - 不被调用的函数应该及时代码里面删除
* 用多态替代 if/else 或者 switch/case